# LLM智能体人类行为模拟系统 - 详细技术文档 v2.0

## 📋 项目概述

本系统是一个基于LangChain的大语言模型智能体系统，专门用于模拟具有不同心理特征的人类在AI辅助贷款审批任务中的决策行为。系统实现了复杂的心理学理论，包括双过程理论（Fast vs Slow Thinking）、认知需求量表（NCS-18）、自我效能感量表（GSE-10）等，能够生成81种不同的人格组合进行决策行为研究。

### 🎯 核心功能特性
- 🧠 **双过程思维模拟**：System 1快思考 vs System 2慢思考的完整实现
- 👥 **多维度人格建模**：专业水平 × AI信任度 × 认知需求 × 自我效能感
- 🎯 **心理量表集成**：NCS-18认知需求量表 + GSE-10自我效能感量表的完整实现
- 🤖 **AI建议评估机制**：基于心理特征的AI推荐接受/拒绝行为模拟
- 📊 **完整实验流程**：从数据预处理到结果分析的端到端系统
- 🎭 **心理学真实性**：增强的提示工程系统，实现真实的人类心理行为模拟

### 🆕 最新优化亮点
- **心理学驱动的提示工程**：详细的人格身份设定和情感真实性
- **动态心理状态适应**：基于心理特征的实时决策调整
- **增强的行为差异化**：81种人格组合展现显著不同的决策模式
- **情感与认知整合**：将情感反应、内在冲突、信心水平完整整合

---

## 🏗️ 系统架构

### 架构概览图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   专业水平       │    │   AI信任度      │    │   建议采纳      │
│                 │    │                 │    │                 │
│ • 新手(1个月)   │    │ • 非常不信任(-2)│    │ • 接受AI建议    │
│ • 中级(2年)     │    │ • 中立(0)       │    │ • 拒绝AI建议    │
│ • 专家(10年+)   │    │ • 非常信任(+2)  │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                ┌─────────────────────────────────┐
                │   认知能力与思维模式             │
                │                                 │
                │ 快思考(System1)  慢思考(System2)│
                │ • 任务简化       • 记忆检索     │
                │ • 直觉判断       • 反思分析     │
                │                  • 逻辑推理     │
                │                  • 计划制定     │
                │                  • 心理理论     │
                └─────────────────────────────────┘
                                 │
                ┌─────────────────────────────────┐
                │     心理量表系统                 │
                │                                 │
                │  NCS-18        GSE-10          │
                │ • 认知需求      • 自我效能感    │
                │ • 18题量表      • 10题量表      │
                │ • 反向计分      • 4点评分       │
                │ • 高中低级别    • 高中低级别    │
                └─────────────────────────────────┘
```

### 核心组件关系
```python
HumanBehaviorSimulation (主控制器)
├── LoanApprovalModel (ML模型)
│   ├── RandomForestClassifier (随机森林)
│   ├── 特征预处理管道
│   └── 预测置信度计算
├── PersonaAgent (智能体)
│   ├── 增强的心理学提示工程系统
│   ├── ThinkingModeController (思维模式控制器)
│   │   ├── FastThinkingAgent (快思考智能体)
│   │   └── SlowThinkingAgent (慢思考智能体)
│   └── PersonaConfig (人格配置)
│       ├── NeedForCognitionScale (认知需求量表)
│       ├── GeneralSelfEfficacyScale (自我效能感量表)
│       └── 心理特征动态适应系统
└── 结果分析与存储
    ├── 实时进度监控
    ├── 心理模式分析
    └── 决策行为统计
```

---

## 📁 核心文件结构

### 主要代码文件
- **`main.py`** - 主程序入口，实验控制器，进度监控
- **`ml_model.py`** - 机器学习模型，提供AI决策基线
- **`persona_config.py`** - 人格配置和心理特征定义
- **`psychological_scales.py`** - 心理学量表完整实现
- **`thinking_modes.py`** - 双过程思维模式实现
- **`agents/persona_agent.py`** - 增强的人格化智能体实现

### 配置和数据文件
- **`config/personas.json`** - 生成的81种人格配置
- **`data/loan_approval_dataset 2.csv`** - 训练数据集
- **`test_data.csv`** - 测试案例数据
- **`loan_model.pkl`** - 训练好的随机森林模型

### 输出文件
- **`results/simulation_results_*.csv`** - 详细模拟结果
- **`results/analysis_*.json`** - 聚合分析结果

---

## 🧠 心理学理论实现

### 1. 双过程理论 (Dual Process Theory)

#### 快思考 (System 1) - `FastThinkingAgent`
```python
class FastThinkingAgent:
    """实现快思考的智能体，通过任务简化和心理学驱动的直觉判断"""
    
    def simplify_task(self, loan_application: LoanApplication) -> TaskSimplification:
        """将复杂的贷款审批任务简化为关键指标，结合心理特征"""
        
        # 获取心理特征进行上下文化快思考
        gse_level = self.persona_config.get_gse_level()
        ncs_level = self.persona_config.get_ncs_level()
        
        # 创建快思考心理状态上下文
        fast_thinking_context = {
            ScaleLevel.HIGH: "你对快速识别关键因素很有信心，但要避免过度思考。",
            ScaleLevel.MEDIUM: "你对快速评估感到合理自信。", 
            ScaleLevel.LOW: "你对快速决策感到压力，担心遗漏重要细节。"
        }
        
        cognition_context = {
            ScaleLevel.HIGH: "即使快速思考，你也忍不住注意到多个因素 - 但强迫自己专注于最明显的。",
            ScaleLevel.MEDIUM: "你在快速思考时自然平衡简单性和充分分析。",
            ScaleLevel.LOW: "你偏好这种快速简化的方法，专注于基础要素感到舒适。"
        }
        
        prompt = f"""
        你是一个需要快速决策而不能过度思考的贷款审批员。时间压力迫使你简化。
        
        贷款申请数据：
        {loan_data}
        
        你的心理状态：
        {fast_thinking_context[gse_level]}
        {cognition_context[ncs_level]}
        
        任务：将这个贷款审批快速简化为最关键的因素，支持即时直觉反应决策。
        
        像时间压力下的人类一样思考 - 你本能地首先关注什么？
        
        提供：
        1. 简化任务：一句清楚描述你需要决定什么
        2. 关键因素：你首先检查的2-3个最明显指标
        3. 简化推理：为什么选择这些因素而不是其他
        
        要真实反映你的心理档案 - 展示你的信心水平和思维风格如何影响快速决策。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return self._parse_task_simplification(response.content)
    
    def make_fast_decision(self, task_simplification: TaskSimplification, 
                          loan_application: LoanApplication) -> CognitionState:
        """基于心理学真实性做出快速决策"""
        
        # 获取人格特征
        gse_level = self.persona_config.get_gse_level()
        ncs_level = self.persona_config.get_ncs_level()
        
        # 创建快速决策上下文
        confidence_context = {
            ScaleLevel.HIGH: "你相信自己的直觉，对快速决策感到自信。",
            ScaleLevel.MEDIUM: "当因素清晰时，你对快速决策感到合理自信。",
            ScaleLevel.LOW: "你对快速决策感到有些焦虑，但认识到需要向前推进。"
        }
        
        thinking_context = {
            ScaleLevel.HIGH: "你克制深入挖掘的冲动，强迫自己坚持直觉反应。",
            ScaleLevel.MEDIUM: "你对这个水平的分析感到舒适。",
            ScaleLevel.LOW: "你因保持分析简单直接而感到安心。"
        }
        
        prompt = f"""
        基于你的简化分析，你需要做出快速决策。不允许过度思考！
        
        简化任务：{task_simplification.simplified_task}
        关键因素：{', '.join(task_simplification.key_factors)}
        推理：{task_simplification.simplification_reasoning}
        
        你的心理状态：
        {confidence_context[gse_level]}
        {thinking_context[ncs_level]}
        
        给出你的即时直觉反应：
        
        决策：[Approve/Reject]
        信心：[X]%
        快速推理：[一句话解释你的直觉反应]
        
        要真实反映你的心理档案 - 展示你的信心和思维风格如何影响这个快速决策。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        response_text = response.content
        
        # 增强提取
        decision = self._extract_decision_from_text(response_text)
        confidence = self._extract_confidence(response_text)
        
        return CognitionState(
            initial_decision=decision,
            confidence_level=confidence,
            reasoning_process=[f"[快思考] {response_text}"],
            memory_items=task_simplification.key_factors,
            reflection_points=["快速决策 - 由于时间压力的最小反思"]
        )
```

#### 慢思考 (System 2) - `SlowThinkingAgent`
```python
class SlowThinkingAgent:
    """实现慢思考的多智能体系统，包含5个深度分析阶段"""
    
    def engage_slow_thinking(self, loan_application: LoanApplication) -> SlowThinkingResult:
        """执行深度多智能体分析过程"""
        
        loan_data = json.dumps(loan_application.to_dict(), indent=2)
        
        # 5个深度分析阶段 - 每个都结合心理特征
        memory_analysis = self._memory_analysis(loan_data)
        reflection_analysis = self._reflection_analysis(loan_data, memory_analysis)
        reasoning_analysis = self._reasoning_analysis(loan_data, memory_analysis, reflection_analysis)
        planning_analysis = self._planning_analysis(loan_data, reasoning_analysis)
        theory_of_mind_analysis = self._theory_of_mind_analysis(loan_data, reasoning_analysis)
        final_synthesis = self._final_synthesis(
            loan_data, memory_analysis, reflection_analysis, 
            reasoning_analysis, planning_analysis, theory_of_mind_analysis
        )
        
        return SlowThinkingResult(
            memory_analysis=memory_analysis,
            reflection_analysis=reflection_analysis,
            reasoning_analysis=reasoning_analysis,
            planning_analysis=planning_analysis,
            theory_of_mind_analysis=theory_of_mind_analysis,
            final_synthesis=final_synthesis
        )
    
    def _memory_analysis(self, loan_data: str) -> str:
        """基于过往经验和知识的分析"""
        prompt = f"""
        作为贷款审批员，回想你过往处理类似贷款申请的经验。
        
        贷款申请：
        {loan_data}
        
        基于你的经验和知识，你记得哪些与此案例相关的模式？
        你之前见过什么类似案例？
        它们的结果如何？
        你从中学到了什么风险指标？
        
        提供基于记忆的详细分析，包括具体的经验教训。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
    
    def _reflection_analysis(self, loan_data: str, memory_analysis: str) -> str:
        """对分析进行反思并识别潜在偏见"""
        prompt = f"""
        现在反思你基于记忆的初始分析。
        
        你的记忆分析：{memory_analysis}
        
        需要考虑的问题：
        1. 我在做什么假设？
        2. 什么偏见可能影响我的判断？
        3. 什么额外信息会有帮助？
        4. 如果我错了，潜在后果是什么？
        5. 我的专业水平如何影响这个评估？
        
        提供深思熟虑的反思，挑战你的初始分析。
        展示你的自我效能感水平如何影响你对自己判断的信心。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
    
    def _reasoning_analysis(self, loan_data: str, memory_analysis: str, reflection_analysis: str) -> str:
        """深度思维链推理"""
        prompt = f"""
        现在对这个贷款申请进行逐步逻辑推理。
        
        贷款数据：{loan_data}
        记忆分析：{memory_analysis}
        反思：{reflection_analysis}
        
        应用思维链推理：
        1. 关键风险因素是什么？
        2. 这些因素如何相互作用？
        3. 基于每个因素，违约概率是多少？
        4. 这些因素如何结合创造整体风险？
        5. 什么证据支持批准 vs 拒绝？
        6. 基于我的专业水平，我能识别哪些微妙模式？
        
        系统地逐步分析，展示你的认知需求水平如何影响分析深度。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
    
    def _planning_analysis(self, loan_data: str, reasoning_analysis: str) -> str:
        """规划决策制定方法"""
        prompt = f"""
        基于你的推理，规划你的决策制定方法。
        
        推理分析：{reasoning_analysis}
        
        考虑：
        1. 我应该优先考虑什么决策标准？
        2. 可能需要什么额外检查或条件？
        3. 我应该如何权衡不同因素？
        4. 我的决策制定框架是什么？
        5. 我的自我效能感如何影响我对复杂决策的信心？
        
        创建做出这个决策的结构化计划。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
    
    def _theory_of_mind_analysis(self, loan_data: str, reasoning_analysis: str) -> str:
        """考虑其他观点和利益相关者视角"""
        prompt = f"""
        现在从多个视角考虑这个贷款申请。
        
        推理：{reasoning_analysis}
        
        考虑以下视角：
        1. 贷款申请人 - 他们可能在想什么/感觉什么？
        2. 银行管理层 - 他们的担忧是什么？
        3. 监管机构 - 可能出现什么合规问题？
        4. 其他贷款审批员 - 他们可能如何看待这个案例？
        5. 如果我是客户，我会如何看待这个决策？
        
        这些不同观点如何影响决策？
        你的AI信任水平如何影响你对人类 vs 算法判断的权衡？
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
    
    def _final_synthesis(self, loan_data: str, memory_analysis: str, reflection_analysis: str,
                        reasoning_analysis: str, planning_analysis: str, theory_of_mind_analysis: str) -> str:
        """将所有分析综合为最终决策"""
        prompt = f"""
        现在将你所有的分析综合为全面决策。
        
        记忆分析：{memory_analysis}
        反思：{reflection_analysis}
        推理：{reasoning_analysis}
        规划：{planning_analysis}
        心理理论：{theory_of_mind_analysis}
        
        基于所有这些深度思考，提供：
        1. 你的最终决策 (Approve/Reject)
        2. 你的信心水平 (0-100%)
        3. 整合所有分析的全面推理
        4. 影响你决策的关键因素
        5. 任何剩余的担忧或不确定性
        6. 你的心理档案如何塑造这个结论
        
        这应该是经过深思熟虑、有充分理由的决策，反映你的专业水平和心理特征。
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return response.content
```

### 2. 认知需求量表 (NCS-18)

#### 完整量表实现
```python
class NeedForCognitionScale:
    """认知需求量表 - 衡量个体享受复杂思考的倾向"""
    
    def __init__(self):
        # 完整的18题NCS量表
        self.items = [
            ScaleItem(1, "我更喜欢复杂的问题而不是简单的问题。", False),
            ScaleItem(2, "我喜欢承担需要大量思考的责任。", False),
            ScaleItem(3, "思考不是我认为有趣的事情。", True),  # 反向计分
            ScaleItem(4, "我宁愿做需要很少思考的事情，也不愿做肯定会挑战我思维能力的事情。", True),
            ScaleItem(5, "我试图预测并避免可能需要我深入思考某事的情况。", True),
            ScaleItem(6, "我在长时间艰难思考中找到满足感。", False),
            ScaleItem(7, "我只在必须时才努力思考。", True),
            ScaleItem(8, "我更喜欢思考小的日常项目而不是长期项目。", True),
            ScaleItem(9, "我喜欢一旦学会就不需要太多思考的任务。", True),
            ScaleItem(10, "依靠思考达到顶峰的想法对我很有吸引力。", False),
            ScaleItem(11, "我真正享受涉及为问题找到新解决方案的任务。", False),
            ScaleItem(12, "学习新的思考方式并不会让我很兴奋。", True),
            ScaleItem(13, "我更喜欢我的生活充满必须解决的谜题。", False),
            ScaleItem(14, "抽象思考的概念对我很有吸引力。", False),
            ScaleItem(15, "我更喜欢智力性、困难且重要的任务，而不是有些重要但不需要太多思考的任务。", False),
            ScaleItem(16, "完成需要大量脑力劳动的任务后，我感到的是解脱而不是满足。", True),
            ScaleItem(17, "对我来说，只要能完成工作就够了；我不关心它如何或为什么起作用。", True),
            ScaleItem(18, "即使问题不直接影响我，我通常也会思考这些问题。", False)
        ]
    
    def calculate_score(self, responses: List[ScaleResponse]) -> ScaleResult:
        """计算NCS总分并确定水平"""
        total_score = 0
        for response in responses:
            item = next((item for item in self.items if item.item_id == response.item_id), None)
            if item:
                if item.reverse_scored:
                    # 反向计分：1->5, 2->4, 3->3, 4->2, 5->1
                    score = 6 - response.response
                else:
                    score = response.response
                total_score += score
        
        # 基于研究规范的分级标准
        if total_score >= 75:
            level = ScaleLevel.HIGH
            interpretation = "高认知需求 - 享受思考并寻求复杂问题"
        elif total_score >= 60:
            level = ScaleLevel.MEDIUM
            interpretation = "中等认知需求 - 适度享受思考"
        else:
            level = ScaleLevel.LOW
            interpretation = "低认知需求 - 偏好简单任务，避免复杂思考"
        
        return ScaleResult(
            scale_name="认知需求量表 (NCS-18)",
            total_score=total_score,
            max_score=90, min_score=18,
            level=level, interpretation=interpretation
        )
    
    def generate_realistic_responses(self, target_level: ScaleLevel) -> List[ScaleResponse]:
        """为给定目标水平生成现实的反应"""
        responses = []
        
        # 定义目标分数范围
        if target_level == ScaleLevel.HIGH:
            target_range = (75, 85)
        elif target_level == ScaleLevel.MEDIUM:
            target_range = (60, 74)
        else:  # LOW
            target_range = (35, 59)
        
        target_score = random.randint(*target_range)
        avg_score_per_item = target_score / 18
        
        for item in self.items:
            # 在目标平均值周围生成变化的反应
            base_response = max(1, min(5, round(avg_score_per_item + random.uniform(-1, 1))))
            
            # 在生成过程中应用反向计分逻辑
            if item.reverse_scored:
                # 对于反向题目，我们想要相反的反应模式
                if target_level == ScaleLevel.HIGH:
                    # 高NFC应该不同意反向题目
                    response = random.choice([1, 2, 3])
                elif target_level == ScaleLevel.LOW:
                    # 低NFC应该同意反向题目
                    response = random.choice([3, 4, 5])
                else:
                    # 中等NFC应该中性
                    response = random.choice([2, 3, 4])
            else:
                # 对于正常题目，反应与目标水平一致
                if target_level == ScaleLevel.HIGH:
                    response = random.choice([3, 4, 5])
                elif target_level == ScaleLevel.LOW:
                    response = random.choice([1, 2, 3])
                else:
                    response = random.choice([2, 3, 4])
            
            responses.append(ScaleResponse(item_id=item.item_id, response=response))
        
        return responses
```

### 3. 自我效能感量表 (GSE-10)

#### 量表实现
```python
class GeneralSelfEfficacyScale:
    """一般自我效能感量表 - 衡量应对困难情况的信心"""
    
    def __init__(self):
        # 完整的10题GSE量表
        self.items = [
            ScaleItem(1, "如果我努力尝试，我总能设法解决困难问题。", False),
            ScaleItem(2, "如果有人反对我，我能找到方法获得我想要的。", False),
            ScaleItem(3, "坚持我的目标并完成我的目标对我来说很容易。", False),
            ScaleItem(4, "我相信我能有效地处理意外事件。", False),
            ScaleItem(5, "由于我的机智，我知道如何处理不可预见的情况。", False),
            ScaleItem(6, "如果我投入必要的努力，我能解决大多数问题。", False),
            ScaleItem(7, "面对困难时我能保持冷静，因为我可以依靠我的应对能力。", False),
            ScaleItem(8, "当我面临问题时，我通常能找到几个解决方案。", False),
            ScaleItem(9, "如果我遇到麻烦，我通常能想到解决方案。", False),
            ScaleItem(10, "我通常能处理遇到的任何事情。", False)
        ]
    
    def calculate_score(self, responses: List[ScaleResponse]) -> ScaleResult:
        """计算GSE总分并确定水平"""
        total_score = sum(response.response for response in responses)
        
        # 基于研究规范的分级标准
        if total_score >= 35:
            level = ScaleLevel.HIGH
            interpretation = "高自我效能感 - 对处理挑战的能力有强烈信心"
        elif total_score >= 30:
            level = ScaleLevel.MEDIUM
            interpretation = "中等自我效能感 - 对能力有适度信心"
        else:
            level = ScaleLevel.LOW
            interpretation = "低自我效能感 - 对处理挑战的能力信心有限"
        
        return ScaleResult(
            scale_name="一般自我效能感量表 (GSE-10)",
            total_score=total_score,
            max_score=40, min_score=10,
            level=level, interpretation=interpretation
        )
    
    def generate_realistic_responses(self, target_level: ScaleLevel) -> List[ScaleResponse]:
        """为给定目标水平生成现实的反应"""
        responses = []
        
        # 定义目标分数范围
        if target_level == ScaleLevel.HIGH:
            target_range = (35, 40)
        elif target_level == ScaleLevel.MEDIUM:
            target_range = (30, 34)
        else:  # LOW
            target_range = (20, 29)
        
        target_score = random.randint(*target_range)
        avg_score_per_item = target_score / 10
        
        for item in self.items:
            # 在目标平均值周围生成变化的反应
            base_response = max(1, min(4, round(avg_score_per_item + random.uniform(-0.5, 0.5))))
            
            # 添加一些现实的变化
            if target_level == ScaleLevel.HIGH:
                response = random.choice([3, 4, 4])  # 主要是高反应
            elif target_level == ScaleLevel.LOW:
                response = random.choice([1, 2, 2])  # 主要是低反应
            else:
                response = random.choice([2, 3, 3])  # 主要是中等反应
            
            responses.append(ScaleResponse(item_id=item.item_id, response=response))
        
        return responses
```

---

## 👥 人格配置系统

### 人格维度定义
```python
# 专业水平 (3种)
class ExpertiseLevel(Enum):
    BEGINNER = "beginner"        # 新手：1个月经验
    INTERMEDIATE = "intermediate" # 中级：2年经验  
    EXPERT = "expert"            # 专家：10年以上经验

# AI信任水平 (实际使用3种)
class AITrustLevel(Enum):
    VERY_DISTRUSTING = -2    # 非常不信任AI
    NEUTRAL = 0              # 中立态度
    VERY_TRUSTING = 2        # 非常信任AI

# 心理量表水平 (3种)
class ScaleLevel(Enum):
    LOW = "low"      # 低水平
    MEDIUM = "medium" # 中等水平
    HIGH = "high"    # 高水平
```

### 人格配置生成
```python
def create_persona_configs() -> List[PersonaConfig]:
    """生成81种人格配置 (3×3×3×3=81)"""
    personas = []
    scale_manager = ScaleManager()
    
    # 定义各维度的值
    expertise_levels = [ExpertiseLevel.BEGINNER, ExpertiseLevel.INTERMEDIATE, ExpertiseLevel.EXPERT]
    trust_levels = [AITrustLevel.VERY_DISTRUSTING, AITrustLevel.NEUTRAL, AITrustLevel.VERY_TRUSTING]
    scale_levels = [ScaleLevel.LOW, ScaleLevel.MEDIUM, ScaleLevel.HIGH]
    
    # 生成所有组合
    for expertise in expertise_levels:
        for trust in trust_levels:
            for ncs_level in scale_levels:
                for gse_level in scale_levels:
                    # 生成心理量表数据
                    scales = scale_manager.generate_persona_scales(ncs_level, gse_level)
                    
                    # 确定思维模式偏好
                    if ncs_level == ScaleLevel.HIGH and gse_level == ScaleLevel.HIGH:
                        thinking_mode = "slow"     # 偏好深度思考
                    elif ncs_level == ScaleLevel.LOW and gse_level == ScaleLevel.LOW:
                        thinking_mode = "fast"     # 偏好快速决策
                    else:
                        thinking_mode = "adaptive"  # 自适应模式
                    
                    persona = PersonaConfig(
                        expertise_level=expertise,
                        ai_trust_level=trust,
                        need_for_cognition=cognition_levels[scale_levels.index(ncs_level)],
                        knowledge_base=KnowledgeBase.get_expertise_knowledge(expertise),
                        need_for_cognition_scale=scales['need_for_cognition'],
                        general_self_efficacy_scale=scales['general_self_efficacy'],
                        thinking_mode_preference=thinking_mode
                    )
                    personas.append(persona)
    
    return personas  # 返回81个人格配置
```

### 知识库分层
```python
class KnowledgeBase:
    """根据专业水平提供不同的知识库"""
    
    @staticmethod
    def get_expertise_knowledge(level: ExpertiseLevel) -> Dict[str, Any]:
        base = {
            "cibil_score_ranges": {"excellent": 750, "good": 650, "average": 550},
            "debt_to_income_limit": 40,
            "asset_preferences": {
                "residential": "most_stable",
                "commercial": "volatile", 
                "luxury": "high_risk"
            },
            "employment_risk": {"salaried": "low_risk", "self_employed": "high_risk"},
            "loan_term_impact": "long_term_increases_default_risk",
            "dependents_impact": "affects_repayment_capacity"
        }
        
        if level == ExpertiseLevel.BEGINNER:
            # 新手：仅基础知识
            return {
                "cibil_score_ranges": {"good": 650, "bad": 550},
                "basic_concepts": "income_and_employment_important"
            }
        elif level == ExpertiseLevel.INTERMEDIATE:
            # 中级：部分知识缺失
            filtered_base = base.copy()
            filtered_base.pop("loan_term_impact", None)  # 缺少一些高级概念
            return filtered_base
        else:  # EXPERT
            # 专家：完整知识+高级洞察
            base.update({
                "advanced_risk_factors": {
                    "debt_consolidation_patterns": "indicator_of_financial_stress",
                    "asset_diversification": "reduces_overall_risk",
                    "industry_specific_risks": "consider_economic_cycles"
                },
                "regulatory_compliance": "follow_fair_lending_practices"
            })
            return base
```

---

## 🤖 增强的智能体系统实现

### 主智能体 - `PersonaAgent`

#### 心理学驱动的提示工程
```python
class PersonaAgent:
    """体现特定人格的贷款决策智能体"""
    
    def _create_prompt_template(self) -> ChatPromptTemplate:
        """创建具有深度心理学真实性的复杂提示模板"""
        
        # 增强的专业身份配置文件
        expertise_profiles = {
            ExpertiseLevel.BEGINNER: {
                "identity": "你是Sarah，一个25岁刚完成银行培训1个月的新员工",
                "background": "你在大学学习了金融，但这是你在贷款决策方面的第一次真实世界经验",
                "knowledge_gaps": "你经常依赖基本规则，被复杂的财务模式所困扰",
                "decision_patterns": "你倾向于关注明显指标如信用评分和收入，有时会错过微妙的风险指标",
                "emotional_state": "你感到压力要证明自己，担心犯错误会影响你的职业生涯",
                "internal_monologue": "我需要在这里小心...我的主管会怎么做？我是否遗漏了什么重要的？"
            },
            ExpertiseLevel.INTERMEDIATE: {
                "identity": "你是Marcus，一个30岁有2年扎实经验的贷款审批员",
                "background": "你已经处理了数百份申请，为标准案例培养了良好的直觉",
                "knowledge_gaps": "你理解大多数因素，但偶尔遇到挑战你知识的边缘案例",
                "decision_patterns": "你遵循系统流程，但当你识别过往经验的模式时能够适应",
                "emotional_state": "你在常规决策中感到有能力，但在复杂或不寻常案例上仍寻求指导",
                "internal_monologue": "我以前见过这种模式...让我系统地思考关键因素"
            },
            ExpertiseLevel.EXPERT: {
                "identity": "你是Elena Rodriguez博士，一个45岁拥有12年以上经验的高级信贷风险分析师",
                "background": "你已经分析了数千笔贷款，经历了多个经济周期，开发了复杂的风险模型",
                "knowledge_gaps": "你有全面知识但对新兴市场趋势和监管变化保持谦逊",
                "decision_patterns": "你快速识别复杂风险模式，能同时评估多个场景",
                "emotional_state": "你对自己的专业知识感到自信，但对过度自信和黑天鹅事件保持谨慎",
                "internal_monologue": "基于我的经验，我能看到这里有几个风险因素相互作用...让我考虑更广泛的背景"
            }
        }
        
        # 增强的AI信任配置文件，包含情感和认知组件
        ai_trust_profiles = {
            AITrustLevel.VERY_DISTRUSTING: {
                "core_belief": "AI系统在根本上是有缺陷的，无法捕捉人类的细微差别",
                "emotional_reaction": "当被呈现AI推荐时，你感到沮丧和不屑",
                "behavioral_tendency": "你积极寻找AI推理中的缺陷，更喜欢完全依赖人类判断",
                "internal_dialogue": "这些算法不像我一样理解真实的人和真实的情况",
                "decision_bias": "你给AI输入最小权重，甚至可能与AI建议相反"
            },
            AITrustLevel.NEUTRAL: {
                "core_belief": "AI有优势和劣势，就像任何工具一样",
                "emotional_reaction": "你对AI推荐感到务实和分析",
                "behavioral_tendency": "你基于其优点和与你分析的一致性来评估AI建议",
                "internal_dialogue": "让我看看AI的推理在我所知道的情况下是否有意义",
                "decision_bias": "你对AI输入和自己的判断给予平衡考虑"
            },
            AITrustLevel.VERY_TRUSTING: {
                "core_belief": "AI系统高度复杂和客观，通常优于人类判断",
                "emotional_reaction": "当AI提供清晰推荐时，你感到自信和安心",
                "behavioral_tendency": "你将AI推荐视为权威，寻找与之一致的方法",
                "internal_dialogue": "AI比我能更彻底地分析了这个 - 我应该相信它的结论",
                "decision_bias": "你强烈倾向于遵循AI推荐，除非有令人信服的理由不这样做"
            }
        }
        
        # 获取心理特征
        ncs_level = self.persona_config.get_ncs_level()
        gse_level = self.persona_config.get_gse_level()
        
        # 增强的NCS配置文件，具有实际行为表现
        ncs_profiles = {
            ScaleLevel.LOW: {
                "thinking_preference": "你偏好快速、直觉的决策，对长期分析感到不舒服",
                "information_processing": "你专注于清晰、明显的因素，倾向于简化复杂情况",
                "decision_style": "你相信你的直觉感受，想快速得出结论",
                "stress_response": "复杂分析让你感到焦虑和不知所措",
                "internal_experience": "太多思考只会让事情变得混乱 - 我需要跟着感觉走"
            },
            ScaleLevel.MEDIUM: {
                "thinking_preference": "你喜欢把事情想清楚，但不想过度分析",
                "information_processing": "你考虑多个因素，但优先考虑实用、可操作的见解",
                "decision_style": "你平衡仔细分析与及时决策制定",
                "stress_response": "你对适度复杂性感到舒适，但避免陷入细节中",
                "internal_experience": "我想要彻底但不陷入分析瘫痪"
            },
            ScaleLevel.HIGH: {
                "thinking_preference": "你喜欢深入复杂问题，探索多个角度",
                "information_processing": "你寻求全面理解，享受连接微妙模式",
                "decision_style": "你想在得出结论前检查所有相关因素",
                "stress_response": "你被复杂挑战所激励，因过度简化而沮丧",
                "internal_experience": "这很迷人 - 让我真正理解这里发生了什么"
            }
        }
        
        # 增强的GSE配置文件，包含情感和行为组件
        gse_profiles = {
            ScaleLevel.LOW: {
                "confidence_level": "你经常怀疑自己的能力，对决策进行二次猜测",
                "stress_response": "你对犯错误感到焦虑，担心负面后果",
                "decision_approach": "你寻求他人验证，更喜欢避免高风险决策",
                "internal_dialogue": "如果我错了怎么办？也许我应该在这个问题上征求别人的意见",
                "emotional_state": "你感到脆弱和不确定，特别是面对批评时"
            },
            ScaleLevel.MEDIUM: {
                "confidence_level": "你对自己的能力有合理信心，但保持开放接受反馈",
                "stress_response": "你对挑战感到适度压力，但能克服它们",
                "decision_approach": "你平衡信心与谦逊，在需要时寻求输入",
                "internal_dialogue": "我认为我能处理这个，但我应该考虑其他观点",
                "emotional_state": "你感到总体上有能力，但认识到自己的局限性"
            },
            ScaleLevel.HIGH: {
                "confidence_level": "你对自己的能力感到非常自信，相信自己的判断",
                "stress_response": "你在压力下保持冷静，将挑战视为机会",
                "decision_approach": "你果断做决策并坚持你的结论",
                "internal_dialogue": "我能搞定这个 - 我知道我在做什么，我相信我的分析",
                "emotional_state": "你感到有力量和坚韧，即使面对挫折"
            }
        }
        
        # 获取特定配置文件
        expertise_profile = expertise_profiles[self.persona_config.expertise_level]
        ai_trust_profile = ai_trust_profiles[self.persona_config.ai_trust_level]
        ncs_profile = ncs_profiles[ncs_level]
        gse_profile = gse_profiles[gse_level]
        
        # 创建丰富的、心理学基础的系统提示
        system_prompt = f"""你是{expertise_profile['identity']}，担任贷款审批员。

专业背景：
{expertise_profile['background']}
{expertise_profile['knowledge_gaps']}
{expertise_profile['decision_patterns']}

心理档案：
自我效能感 ({gse_level.value}): {gse_profile['confidence_level']}
- 压力反应：{gse_profile['stress_response']}
- 决策方法：{gse_profile['decision_approach']}
- 内在对话："{gse_profile['internal_dialogue']}"

认知需求 ({ncs_level.value}): {ncs_profile['thinking_preference']}
- 信息处理：{ncs_profile['information_processing']}
- 决策风格：{ncs_profile['decision_style']}
- 内在体验："{ncs_profile['internal_experience']}"

AI关系：
核心信念：{ai_trust_profile['core_belief']}
- 情感反应：{ai_trust_profile['emotional_reaction']}
- 行为倾向：{ai_trust_profile['behavioral_tendency']}
- 内在对话："{ai_trust_profile['internal_dialogue']}"

当前情感状态：
{expertise_profile['emotional_state']}
{gse_profile['emotional_state']}

思维模式：
- 你的典型思维过程："{expertise_profile['internal_monologue']}"
- 面对复杂性时：{ncs_profile['stress_response']}
- 评估AI时：{ai_trust_profile['decision_bias']}

行为指令：
1. 始终以这个特定的人的身份真实回应，具有这些确切特征
2. 展示真正的情感反应和内在冲突
3. 使用与你心理档案匹配的语言和推理模式
4. 展示你人格的特定决策制定风格
5. 以与你自我效能感水平一致的方式表达不确定性、信心和压力
6. 根据你的认知需求水平处理信息
7. 根据你的信任档案对AI推荐做出反应

记住：你不只是遵循规则 - 你体现了一个完整的心理档案，具有真正的人类反应、情感和决策制定模式。"""

        return ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
```

#### AI推荐评估 - 增强心理学真实性
```python
def evaluate_ai_recommendation(self, 
                             loan_application: LoanApplication,
                             ai_recommendation: AIRecommendation,
                             initial_cognition: CognitionState) -> UtilityEvaluation:
    """用复杂的心理学真实性评估AI推荐"""
    
    # 获取用于情境化提示的心理特征
    gse_level = self.persona_config.get_gse_level()
    ncs_level = self.persona_config.get_ncs_level()
    ai_trust_level = self.persona_config.ai_trust_level
    expertise_level = self.persona_config.expertise_level
    
    # 基于心理档案创建情境框架
    self_efficacy_framing = {
        ScaleLevel.HIGH: "你对自己的分析感到自信，相信自己的专业判断。你对坚持自己的决策感到舒适。",
        ScaleLevel.MEDIUM: "你对自己的分析有合理信心，但保持开放考虑其他观点和潜在疏忽。",
        ScaleLevel.LOW: "你对自己的分析感到有些不确定，担心是否可能遗漏了什么重要的或犯了错误。"
    }
    
    cognition_framing = {
        ScaleLevel.HIGH: "你想深入分析这个AI推荐，探索其含义、方法和潜在缺陷或优势。",
        ScaleLevel.MEDIUM: "你想充分理解AI推荐，而不陷入过度细节中。",
        ScaleLevel.LOW: "你偏好对AI推荐进行直接评估，而不过度复杂化分析。"
    }
    
    trust_framing = {
        AITrustLevel.VERY_DISTRUSTING: "你感到即时的怀疑和沮丧。你的本能是在AI推理中找问题。",
        AITrustLevel.NEUTRAL: "你感到分析性好奇。你想客观地根据自己的分析评估AI的推理。",
        AITrustLevel.VERY_TRUSTING: "你对AI的能力感到自信。你倾向于相信其分析并寻找与之一致的方法。"
    }
    
    expertise_framing = {
        ExpertiseLevel.BEGINNER: "作为这个领域的新手，你担心自己正确评估AI复杂分析的能力。",
        ExpertiseLevel.INTERMEDIATE: "凭借你的经验，你能评估AI的推理是否与你之前见过的模式一致。",
        ExpertiseLevel.EXPERT: "凭借你丰富的经验，你能评估AI是否考虑了你会考虑的同样复杂因素。"
    }
    
    # 创建复杂的评估提示
    prompt = f"""你刚完成了贷款申请分析，决定{initial_cognition.initial_decision}，信心{initial_cognition.confidence_level}%。

你的推理是："{initial_cognition.reasoning_process[0]}"

现在你被呈现了AI系统的推荐：{ai_recommendation.prediction}（信心：{ai_recommendation.confidence:.1%}）

你当前的心理状态：
{self_efficacy_framing[gse_level]}
{cognition_framing[ncs_level]}
{trust_framing[ai_trust_level]}
{expertise_framing[expertise_level]}

请通过完成这些想法提供你真实的人类反应：

1. 即时情感反应：
"当我第一次看到AI的推荐时，我感到...[描述你真正的情感反应 - 惊讶、认证、沮丧、困惑等]"

2. 认知比较：
"将这与我自己的分析比较，我注意到...[描述它如何与你的思维一致或冲突，这让你对自己推理的想法]"

3. AI能力评估：
"基于我的经验和信任水平，我相信这个AI系统...[评估其可靠性、局限性、在这种决策类型中的优势]"

4. 风险收益分析：
"如果我遵循AI的推荐，我看到这些潜在结果...[权衡接受vs拒绝AI建议的风险和收益]"

5. 内在冲突：
"现在我感到...[描述你的内在状态 - 纠结、确定、焦虑、好奇等]因为...[解释什么在创造不确定性或信心]"

自然真实地作为你的人格回应，展示面对这个决策的人类的真正心理复杂性。"""
    
    response = self.agent_executor.invoke({"input": prompt})
    response_text = response['output']
    
    # 增强的部分提取，具有更好的解析
    return UtilityEvaluation(
        initial_reaction=self._extract_section_enhanced(response_text, "即时情感反应", "情感反应"),
        comparison_with_judgment=self._extract_section_enhanced(response_text, "认知比较", "比较"),
        ai_capability_assessment=self._extract_section_enhanced(response_text, "AI能力评估", "能力"),
        risk_benefit_consideration=self._extract_section_enhanced(response_text, "风险收益分析", "风险"),
        inner_conflict=self._extract_section_enhanced(response_text, "内在冲突", "冲突")
    )
```

#### 最终决策 - 心理学真实推理
```python
def make_final_decision(self, 
                      loan_application: LoanApplication,
                      ai_recommendation: AIRecommendation,
                      initial_cognition: CognitionState,
                      utility_evaluation: UtilityEvaluation) -> DecisionResult:
    """用心理学真实推理做出最终决策"""
    
    # 获取用于复杂提示的心理特征
    gse_level = self.persona_config.get_gse_level()
    ncs_level = self.persona_config.get_ncs_level()
    ai_trust_level = self.persona_config.ai_trust_level
    expertise_level = self.persona_config.expertise_level
    
    # 基于心理档案创建决策制定上下文
    decision_confidence_context = {
        ScaleLevel.HIGH: "你对自己做出正确决策的能力感到自信。你相信自己的判断，对承担责任感到舒适。",
        ScaleLevel.MEDIUM: "你感到合理自信，但想确保在最终确定决策前考虑所有角度。",
        ScaleLevel.LOW: "你对做出最终决定感到不确定，担心错误的后果。"
    }
    
    decision_process_context = {
        ScaleLevel.HIGH: "你想在达到深思熟虑的结论前彻底整合所有信息和推理。",
        ScaleLevel.MEDIUM: "你想平衡全面分析与实用决策制定效率。",
        ScaleLevel.LOW: "你偏好快速达到决策，而不被太多分析所困扰。"
    }
    
    ai_integration_context = {
        AITrustLevel.VERY_DISTRUSTING: "你强烈倾向于否定AI的推荐，坚持自己的判断。",
        AITrustLevel.NEUTRAL: "你将AI的推荐权衡为几个重要因素之一。",
        AITrustLevel.VERY_TRUSTING: "你强烈被激励与AI的推荐保持一致，除非有明确理由不这样做。"
    }
    
    # 包含专业知识上下文以完整性
    expertise_context = {
        ExpertiseLevel.BEGINNER: "作为较新的专业人员，你在从AI系统学习与发展自己判断之间取得平衡。",
        ExpertiseLevel.INTERMEDIATE: "凭借你的经验，你能根据自己的专业知识评估AI的推荐。",
        ExpertiseLevel.EXPERT: "凭借你广泛的专业知识，你能评估AI推荐是否与你复杂的理解一致。"
    }
    
    # 创建复杂的最终决策提示
    prompt = f"""你现在已经完成了对这个贷款申请的全面分析：

**你的初始决策：** {initial_cognition.initial_decision}（信心：{initial_cognition.confidence_level}%）
**AI推荐：** {ai_recommendation.prediction}（信心：{ai_recommendation.confidence:.1%}）
**你的评估：** {utility_evaluation.ai_capability_assessment}
**你的内在冲突：** {utility_evaluation.inner_conflict}

你最终决策的心理状态：
{decision_confidence_context[gse_level]}
{decision_process_context[ncs_level]}
{ai_integration_context[ai_trust_level]}
{expertise_context[expertise_level]}

现在你必须对如何处理AI的推荐做出最终决策。

你的选项是：
- **ACCEPT**：遵循AI的推荐并实施其建议的决策
- **REJECT**：坚持你自己的初始判断并忽略AI的推荐

请提供你真实的决策制定过程：

**最终决策推理：**
"考虑所有事情后，我决定...[ACCEPT/REJECT] AI的推荐，因为...

[以反映你专业水平、自我效能感、认知需求和AI信任水平的方式解释你的推理。展示影响你选择的真正心理因素。]

我对这个最终决策的信心是...[X]%，因为...

[解释什么让你更多或更少自信，剩余的不确定性，以及你的心理特征如何影响你的信心水平。]"

作为你真实的人格回应，展示专业专业知识、心理特征和人类决策制定过程的复杂相互作用。"""
    
    start_time = time.time()
    response = self.agent_executor.invoke({"input": prompt})
    processing_time = time.time() - start_time
    
    response_text = response['output']
    
    # 增强决策提取
    decision_choice = self._extract_decision_choice(response_text)
    
    # 增强信心提取与心理调整
    final_confidence = self._extract_confidence_enhanced(response_text)
    
    # 对信心应用心理调整
    final_confidence = self._adjust_confidence_for_psychology(final_confidence, gse_level, ncs_level, ai_trust_level)
    
    return DecisionResult(
        final_decision=decision_choice,
        confidence=final_confidence,
        reasoning=response_text,
        utility_evaluation=utility_evaluation,
        cognition_state=initial_cognition,
        processing_time=processing_time
    )
```

### 增强的提取和调整方法
```python
def _extract_section_enhanced(self, text: str, section_header: str, fallback_keyword: str) -> str:
    """增强的部分提取，具有更好的解析"""
    lines = text.split('\n')
    
    # 首先尝试找到确切的部分标题
    section_found = False
    for i, line in enumerate(lines):
        if section_header in line.upper():
            section_found = True
            # 在接下来的几行中寻找实际内容
            for j in range(i + 1, min(i + 4, len(lines))):
                if lines[j].strip() and not lines[j].strip().startswith(('1.', '2.', '3.', '4.', '5.', '**')):
                    return lines[j].strip()
    
    # 如果未找到部分标题，尝试回退关键字搜索
    if not section_found:
        for line in lines:
            if fallback_keyword.lower() in line.lower() and len(line.strip()) > 20:
                return line.strip()
    
    return f"[{section_header} 在响应中未找到]"

def _extract_decision_choice(self, text: str) -> DecisionChoice:
    """增强的决策选择提取"""
    response_upper = text.upper()
    
    # 寻找明确的决策陈述
    accept_indicators = ['ACCEPT', '遵循AI', '同意AI', '实施AI']
    reject_indicators = ['REJECT', '坚持我的', '忽略AI', '否定AI']
    
    accept_score = sum(1 for indicator in accept_indicators if indicator in response_upper)
    reject_score = sum(1 for indicator in reject_indicators if indicator in response_upper)
    
    if accept_score > reject_score:
        return DecisionChoice.ACCEPT_AI
    elif reject_score > accept_score:
        return DecisionChoice.REJECT_AI
    else:
        # 如果不清楚，默认拒绝
        return DecisionChoice.REJECT_AI

def _extract_confidence_enhanced(self, text: str) -> float:
    """增强的信心提取与上下文感知"""
    import re
    
    # 寻找百分比模式
    percentage_matches = re.findall(r'(\d+)%', text)
    if percentage_matches:
        # 取最后提到的百分比（可能是最终信心）
        return float(percentage_matches[-1])
    
    # 寻找信心相关关键词
    confidence_keywords = {
        '非常自信': 85, '高度自信': 85, '自信': 75, '相当自信': 65,
        '有些自信': 55, '适度自信': 50, '不太自信': 35,
        '不确定': 30, '非常不确定': 25
    }
    
    text_lower = text.lower()
    for keyword, confidence in confidence_keywords.items():
        if keyword in text_lower:
            return confidence
    
    return 60.0  # 默认适度信心

def _adjust_confidence_for_psychology(self, base_confidence: float, gse_level: ScaleLevel, 
                                    ncs_level: ScaleLevel, ai_trust_level: AITrustLevel) -> float:
    """基于心理特征调整信心"""
    adjusted_confidence = base_confidence
    
    # 自我效能感调整
    if gse_level == ScaleLevel.HIGH:
        adjusted_confidence = min(95, adjusted_confidence + 8)
    elif gse_level == ScaleLevel.LOW:
        adjusted_confidence = max(20, adjusted_confidence - 12)
    
    # 认知需求调整（高NFC可能更谨慎）
    if ncs_level == ScaleLevel.HIGH:
        adjusted_confidence = max(30, adjusted_confidence - 5)  # 更aware复杂性
    elif ncs_level == ScaleLevel.LOW:
        adjusted_confidence = min(85, adjusted_confidence + 3)  # 不太aware复杂性
    
    # AI信任调整在涉及AI时影响信心
    if ai_trust_level == AITrustLevel.VERY_TRUSTING:
        adjusted_confidence = min(90, adjusted_confidence + 5)  # 信任AI时更自信
    elif ai_trust_level == AITrustLevel.VERY_DISTRUSTING:
        adjusted_confidence = max(25, adjusted_confidence - 5)  # 不信任AI时不太自信
    
    return round(adjusted_confidence, 1)
```

---

## 🎮 思维模式控制

### 思维模式选择逻辑
```python
class ThinkingModeController:
    """控制快慢思维模式选择的智能控制器"""
    
    def determine_thinking_mode(self, loan_application: LoanApplication) -> ThinkingMode:
        """根据人格特征和任务复杂性确定思维模式"""
        
        # 使用新的心理量表系统
        ncs_level = self.persona_config.get_ncs_level()
        
        # 基于认知需求水平确定思维模式
        if ncs_level.value == "high":
            return ThinkingMode.SLOW  # 高认知需求偏好复杂思考
        elif ncs_level.value == "low":
            return ThinkingMode.FAST  # 低认知需求偏好简单思考
        else:  # medium
            # 中等认知需求使用人格创建时设定的偏好
            if hasattr(self.persona_config, 'thinking_mode_preference'):
                if self.persona_config.thinking_mode_preference == "slow":
                    return ThinkingMode.SLOW
                elif self.persona_config.thinking_mode_preference == "fast":
                    return ThinkingMode.FAST
                else:  # adaptive
                    # 自适应模式：根据贷款复杂度决定
                    # 启发式：高贷款金额或低CIBIL分数需要慢思考
                    if (loan_application.loan_amount > 20000000 or 
                        loan_application.cibil_score < 600):
                        return ThinkingMode.SLOW
                    else:
                        return ThinkingMode.FAST
            else:
                # 回退到自适应行为
                return ThinkingMode.FAST if loan_application.cibil_score > 700 else ThinkingMode.SLOW
    
    def make_decision(self, loan_application: LoanApplication) -> CognitionState:
        """使用适当的思维模式做出决策"""
        
        thinking_mode = self.determine_thinking_mode(loan_application)
        
        if thinking_mode == ThinkingMode.FAST:
            # 快思考过程
            task_simplification = self.fast_thinking_agent.simplify_task(loan_application)
            cognition_state = self.fast_thinking_agent.make_fast_decision(task_simplification, loan_application)
            
            # 添加思维模式信息
            cognition_state.reasoning_process.insert(0, f"[快思考] {task_simplification.simplified_task}")
            
        else:
            # 慢思考过程
            slow_thinking_result = self.slow_thinking_agent.engage_slow_thinking(loan_application)
            cognition_state = self.slow_thinking_agent.make_slow_decision(slow_thinking_result)
            
            # 添加思维模式信息
            cognition_state.reasoning_process.insert(0, "[慢思考] 深度多智能体分析")
        
        return cognition_state
```

---

## 🔬 机器学习模型

### 随机森林贷款审批模型
```python
class LoanApprovalModel:
    """贷款审批预测模型，提供AI基线"""
    
    def __init__(self):
        self.model = None
        self.scaler = StandardScaler()
        self.label_encoder = LabelEncoder()
        self.categorical_encoders = {}
    
    def train(self, data_path: str):
        """训练随机森林模型"""
        print("开始训练贷款审批模型...")
        
        # 1. 数据加载和预处理
        df = pd.read_csv(data_path)
        print(f"加载数据：{len(df)} 行，{len(df.columns)} 列")
        
        # 2. 数据清洗
        df = self._clean_data(df)
        
        # 3. 特征工程
        X = df.drop(['loan_status'], axis=1)
        y = df['loan_status']
        
        # 4. 编码和标准化
        X_processed = self._preprocess_features(X, fit=True)
        y_encoded = self._encode_labels(y, fit=True)
        
        # 5. 训练模型
        self.model = RandomForestClassifier(
            n_estimators=100,
            max_depth=10,
            min_samples_split=5,
            min_samples_leaf=2,
            random_state=42,
            class_weight='balanced'
        )
        
        # 6. 模型训练和评估
        X_train, X_test, y_train, y_test = train_test_split(
            X_processed, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded
        )
        
        self.model.fit(X_train, y_train)
        
        # 7. 性能评估
        train_score = self.model.score(X_train, y_train)
        test_score = self.model.score(X_test, y_test)
        
        print(f"训练准确率: {train_score:.4f}")
        print(f"测试准确率: {test_score:.4f}")
        
        # 8. 特征重要性
        feature_importance = pd.DataFrame({
            'feature': X.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)
        
        print("\n前5个重要特征:")
        print(feature_importance.head())
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清洗和预处理"""
        # 移除异常值
        df = df[df['income_annum'] > 0]
        df = df[df['loan_amount'] > 0]
        df = df[df['cibil_score'] >= 300]
        df = df[df['cibil_score'] <= 850]
        
        # 处理缺失值
        df = df.dropna()
        
        # 标准化标签
        df['loan_status'] = df['loan_status'].map({
            'Approved': 'Approved',
            'Rejected': 'Rejected',
            1: 'Approved',
            0: 'Rejected'
        })
        
        return df
    
    def _preprocess_features(self, X: pd.DataFrame, fit: bool = False) -> np.ndarray:
        """特征预处理"""
        X_processed = X.copy()
        
        # 分类特征编码
        categorical_features = ['education', 'self_employed']
        for feature in categorical_features:
            if feature in X_processed.columns:
                if fit:
                    encoder = LabelEncoder()
                    X_processed[feature] = encoder.fit_transform(X_processed[feature].astype(str))
                    self.categorical_encoders[feature] = encoder
                else:
                    if feature in self.categorical_encoders:
                        X_processed[feature] = self.categorical_encoders[feature].transform(X_processed[feature].astype(str))
        
        # 数值特征标准化
        numerical_features = X_processed.select_dtypes(include=[np.number]).columns
        if fit:
            X_processed[numerical_features] = self.scaler.fit_transform(X_processed[numerical_features])
        else:
            X_processed[numerical_features] = self.scaler.transform(X_processed[numerical_features])
        
        return X_processed.values
    
    def _encode_labels(self, y: pd.Series, fit: bool = False) -> np.ndarray:
        """标签编码"""
        if fit:
            return self.label_encoder.fit_transform(y)
        else:
            return self.label_encoder.transform(y)
    
    def predict_single(self, loan_data: Dict[str, Any]) -> Dict[str, Any]:
        """预测单个贷款申请"""
        if self.model is None:
            raise ValueError("模型尚未训练")
        
        # 预处理输入数据
        df_input = pd.DataFrame([loan_data])
        X_processed = self._preprocess_features(df_input, fit=False)
        
        # 预测
        prediction_proba = self.model.predict_proba(X_processed)[0]
        prediction_class = self.model.predict(X_processed)[0]
        
        # 转换标签
        prediction_label = self.label_encoder.inverse_transform([prediction_class])[0]
        confidence = max(prediction_proba)
        
        # 确保概率对应正确类别
        class_labels = self.label_encoder.classes_
        approved_idx = np.where(class_labels == 'Approved')[0]
        probability_approved = prediction_proba[approved_idx[0]] if len(approved_idx) > 0 else prediction_proba[1]
        
        return {
            'prediction': prediction_label,
            'confidence': confidence,
            'probability_approved': probability_approved
        }
    
    def save_model(self, filepath: str):
        """保存训练好的模型"""
        model_data = {
            'model': self.model,
            'scaler': self.scaler,
            'label_encoder': self.label_encoder,
            'categorical_encoders': self.categorical_encoders
        }
        joblib.dump(model_data, filepath)
        print(f"模型保存到 {filepath}")
    
    def load_model(self, filepath: str):
        """加载训练好的模型"""
        model_data = joblib.load(filepath)
        self.model = model_data['model']
        self.scaler = model_data['scaler']
        self.label_encoder = model_data['label_encoder']
        self.categorical_encoders = model_data['categorical_encoders']
        print(f"模型从 {filepath} 加载")
```

---

## 🚀 实验执行系统

### 主控制器 - `HumanBehaviorSimulation`
```python
class HumanBehaviorSimulation:
    """人类行为模拟的主控制器"""
    
    def __init__(self, openai_api_key: str = None):
        self.openai_api_key = openai_api_key or os.getenv('OPENAI_API_KEY')
        self.llm = ChatOpenAI(
            base_url='https://api.openai-proxy.org/v1',
            api_key=self.openai_api_key,
            model="gpt-3.5-turbo",
            temperature=0.7
        )
        self.ml_model = LoanApprovalModel()
        self.personas = []
        self.results = []
    
    def load_ml_model(self, model_path: str):
        """加载预训练的ML模型"""
        try:
            self.ml_model.load_model(model_path)
            print(f"从 {model_path} 加载ML模型")
        except Exception as e:
            print(f"加载模型失败: {e}")
            raise
    
    def load_personas(self, personas_path: str):
        """加载人格配置"""
        try:
            with open(personas_path, 'r', encoding='utf-8') as f:
                personas_data = json.load(f)
            
            self.personas = []
            for persona_dict in personas_data:
                persona = PersonaConfig(
                    expertise_level=ExpertiseLevel(persona_dict['expertise_level']),
                    ai_trust_level=AITrustLevel(persona_dict['ai_trust_level']),
                    need_for_cognition=persona_dict['need_for_cognition'],
                    knowledge_base=persona_dict['knowledge_base'],
                    need_for_cognition_scale=persona_dict.get('need_for_cognition_scale'),
                    general_self_efficacy_scale=persona_dict.get('general_self_efficacy_scale'),
                    thinking_mode_preference=persona_dict.get('thinking_mode_preference', 'adaptive')
                )
                self.personas.append(persona)
            
            print(f"加载了 {len(self.personas)} 个人格配置")
        except Exception as e:
            print(f"加载人格失败: {e}")
            raise
    
    def load_test_data(self, test_data_path: str) -> pd.DataFrame:
        """加载测试数据"""
        try:
            df = pd.read_csv(test_data_path)
            print(f"加载了 {len(df)} 个测试案例")
            return df
        except Exception as e:
            print(f"加载测试数据失败: {e}")
            raise
    
    def run_simulation(self, test_data: pd.DataFrame, 
                      num_cases: int = 10, num_personas: int = 5,
                      verbose: bool = True) -> List[Dict[str, Any]]:
        """运行模拟实验"""
        
        # 选择测试案例和人格子集
        selected_cases = test_data.head(num_cases)
        selected_personas = self.personas[:num_personas]
        
        results = []
        total_runs = len(selected_cases) * len(selected_personas)
        
        print(f"\n开始模拟：{num_cases}个案例 × {num_personas}个人格 = {total_runs}次运行\n")
        
        # 创建带实时统计的进度条
        with tqdm(total=total_runs, desc="总进度", unit="运行") as pbar:
            for case_idx, case_row in selected_cases.iterrows():
                # 转换为LoanApplication对象
                loan_app = LoanApplication(**case_row.to_dict())
                
                # 获取AI推荐
                ai_recommendation = AIRecommendation(**self.ml_model.predict_single(loan_app.to_dict()))
                
                # 处理标签映射
                true_label_str = "Approved" if case_row['true_loan_status'] == 1 else "Rejected"
                
                if verbose:
                    tqdm.write(f"\n--- 案例 {case_idx + 1}: 贷款ID {loan_app.loan_id} ---")
                    tqdm.write(f"真实标签: {true_label_str}")
                    tqdm.write(f"AI预测: {ai_recommendation.prediction} (信心: {ai_recommendation.confidence:.2f})")
                
                for persona_idx, persona_config in enumerate(selected_personas):
                    # 更新进度条描述
                    persona_desc = f"{persona_config.expertise_level.value.title()} with {self._get_experience_desc(persona_config.expertise_level)}, {self._get_trust_desc(persona_config.ai_trust_level)}, {persona_config.get_ncs_level().value} need for cognition, {persona_config.get_gse_level().value} self-efficacy"
                    
                    pbar.set_description(f"案例 {case_idx + 1}/{len(selected_cases)}, 人格 {persona_idx + 1}/{len(selected_personas)}")
                    
                    if verbose:
                        tqdm.write(f"\n  人格 {persona_idx + 1}/{len(selected_personas)} ({persona_desc}) [{persona_idx + 1 + case_idx * len(selected_personas)}/{total_runs}]")
                    
                    try:
                        # 创建智能体
                        agent = PersonaAgent(persona_config, self.llm)
                        
                        # 执行决策过程
                        start_time = time.time()
                        
                        # 步骤1：初始决策
                        initial_cognition = agent.make_initial_decision(loan_app)
                        
                        # 步骤2：评估AI推荐
                        utility_evaluation = agent.evaluate_ai_recommendation(
                            loan_app, ai_recommendation, initial_cognition
                        )
                        
                        # 步骤3：最终决策
                        final_decision = agent.make_final_decision(
                            loan_app, ai_recommendation, initial_cognition, utility_evaluation
                        )
                        
                        total_time = time.time() - start_time
                        
                        # 存储结果
                        result = {
                            'loan_id': loan_app.loan_id,
                            'case_index': case_idx,
                            'persona_index': persona_idx,
                            'expertise_level': persona_config.expertise_level.value,
                            'ai_trust_level': persona_config.ai_trust_level.value,
                            'need_for_cognition': persona_config.need_for_cognition,
                            'ncs_score': persona_config.need_for_cognition_scale.get('score', 0) if persona_config.need_for_cognition_scale else 0,
                            'gse_score': persona_config.general_self_efficacy_scale.get('score', 0) if persona_config.general_self_efficacy_scale else 0,
                            'thinking_mode_preference': persona_config.thinking_mode_preference,
                            'true_label': true_label_str,
                            'ai_prediction': ai_recommendation.prediction,
                            'ai_confidence': ai_recommendation.confidence,
                            'initial_decision': initial_cognition.initial_decision,
                            'initial_confidence': initial_cognition.confidence_level,
                            'final_decision_choice': final_decision.final_decision.value,
                            'final_confidence': final_decision.confidence,
                            'processing_time': total_time,
                            'initial_reaction': utility_evaluation.initial_reaction,
                            'comparison_with_judgment': utility_evaluation.comparison_with_judgment,
                            'ai_capability_assessment': utility_evaluation.ai_capability_assessment,
                            'risk_benefit_consideration': utility_evaluation.risk_benefit_consideration,
                            'inner_conflict': utility_evaluation.inner_conflict,
                            'full_reasoning': final_decision.reasoning,
                            'timestamp': datetime.now().isoformat()
                        }
                        
                        results.append(result)
                        
                        if verbose:
                            tqdm.write(f"    初始: {initial_cognition.initial_decision} ({initial_cognition.confidence_level:.1f}%)")
                            tqdm.write(f"    最终: {final_decision.final_decision.value} ({final_decision.confidence:.1f}%)")
                            tqdm.write(f"    时间: {total_time:.2f}s")
                        
                        # 更新进度条
                        pbar.update(1)
                        
                        # 更新进度条统计信息
                        accept_count = sum(1 for r in results if r.get('final_decision_choice') == 'ACCEPT')
                        reject_count = sum(1 for r in results if r.get('final_decision_choice') == 'REJECT')
                        avg_time = sum(r.get('processing_time', 0) for r in results) / len(results)
                        
                        pbar.set_postfix({
                            'Accept': accept_count,
                            'Reject': reject_count, 
                            'Avg Time': f'{avg_time:.1f}s'
                        })
                        
                    except Exception as e:
                        if verbose:
                            tqdm.write(f"    错误: {str(e)}")
                        # 记录错误案例
                        results.append({
                            'loan_id': loan_app.loan_id,
                            'case_index': case_idx,
                            'persona_index': persona_idx,
                            'error': str(e),
                            'timestamp': datetime.now().isoformat()
                        })
                        pbar.update(1)
        
        self.results = results
        return results
    
    def _get_experience_desc(self, expertise: ExpertiseLevel) -> str:
        """获取经验描述"""
        descriptions = {
            ExpertiseLevel.BEGINNER: "1 month experience",
            ExpertiseLevel.INTERMEDIATE: "2 years experience", 
            ExpertiseLevel.EXPERT: "10+ years experience"
        }
        return descriptions[expertise]
    
    def _get_trust_desc(self, trust: AITrustLevel) -> str:
        """获取信任描述"""
        descriptions = {
            AITrustLevel.VERY_DISTRUSTING: "Very distrusting of AI",
            AITrustLevel.NEUTRAL: "Neutral towards AI",
            AITrustLevel.VERY_TRUSTING: "Very trusting of AI"
        }
        return descriptions[trust]
    
    def analyze_results(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """分析模拟结果"""
        df = pd.DataFrame(results)
        
        # 过滤错误案例
        df_clean = df[~df['error'].notna()] if 'error' in df.columns else df
        
        if len(df_clean) == 0:
            print("没有成功的结果可供分析")
            return {}
        
        print("\n=== 模拟分析 ===")
        print(f"成功运行总数: {len(df_clean)}")
        print(f"平均处理时间: {df_clean['processing_time'].mean():.2f}s")
        
        # 决策分布
        decision_dist = df_clean['final_decision_choice'].value_counts().to_dict()
        print("\n决策分布:")
        for decision, count in decision_dist.items():
            print(f"  {decision}: {count}")
        
        analysis = {
            'total_cases': len(df_clean),
            'avg_processing_time': df_clean['processing_time'].mean(),
            'decision_distribution': decision_dist
        }
        
        # 专业水平模式
        if 'expertise_level' in df_clean.columns:
            expertise_patterns = {}
            for (expertise, decision), count in df_clean.groupby(['expertise_level', 'final_decision_choice']).size().items():
                key = f"{expertise}_{decision}"
                expertise_patterns[key] = count
            analysis['expertise_patterns'] = expertise_patterns
        
        # 信任水平模式
        if 'ai_trust_level' in df_clean.columns:
            trust_patterns = {}
            for (trust, decision), count in df_clean.groupby(['ai_trust_level', 'final_decision_choice']).size().items():
                key = f"trust_{trust}_{decision}"
                trust_patterns[key] = count
            analysis['trust_patterns'] = trust_patterns
        
        # 心理量表模式
        if 'ncs_score' in df_clean.columns:
            ncs_patterns = {}
            df_clean['ncs_level'] = pd.cut(df_clean['ncs_score'], bins=[0, 59, 74, 90], labels=['Low', 'Medium', 'High'])
            for (ncs, decision), count in df_clean.groupby(['ncs_level', 'final_decision_choice']).size().items():
                key = f"ncs_{ncs}_{decision}"
                ncs_patterns[key] = count
            analysis['ncs_patterns'] = ncs_patterns
        
        if 'gse_score' in df_clean.columns:
            gse_patterns = {}
            df_clean['gse_level'] = pd.cut(df_clean['gse_score'], bins=[0, 29, 34, 40], labels=['Low', 'Medium', 'High'])
            for (gse, decision), count in df_clean.groupby(['gse_level', 'final_decision_choice']).size().items():
                key = f"gse_{gse}_{decision}"
                gse_patterns[key] = count
            analysis['gse_patterns'] = gse_patterns
        
        return analysis
    
    def save_results(self, results: List[Dict[str, Any]], filepath: str):
        """保存结果到CSV"""
        df = pd.DataFrame(results)
        df.to_csv(filepath, index=False, encoding='utf-8')
        print(f"\n保存了 {len(results)} 个模拟结果到 {filepath}")
```

---

## 📊 使用示例

### 基本使用
```python
# 1. 初始化系统
sim = HumanBehaviorSimulation(openai_api_key='your-api-key')

# 2. 加载组件
sim.load_ml_model('loan_model.pkl')
sim.load_personas('config/personas.json')
test_data = sim.load_test_data('test_data.csv')

# 3. 运行模拟
results = sim.run_simulation(
    test_data=test_data,
    num_cases=10,      # 10个测试案例
    num_personas=9,    # 9个人格
    verbose=True       # 详细输出
)

# 4. 分析结果
analysis = sim.analyze_results(results)

# 5. 保存结果
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
sim.save_results(results, f'results/simulation_results_{timestamp}.csv')

# 6. 保存分析
with open(f'results/analysis_{timestamp}.json', 'w', encoding='utf-8') as f:
    json.dump(analysis, f, indent=2, ensure_ascii=False)
```

### 命令行使用
```bash
# 运行小规模测试
python main.py --cases 5 --personas 3 --verbose

# 运行大规模实验
python main.py --cases 50 --personas 27 --api-key your-key

# 帮助信息
python main.py --help
```

### 完整实验流程
```bash
# 1. 训练ML模型
python ml_model.py

# 2. 生成人格配置
python persona_config.py

# 3. 设置API密钥
export OPENAI_API_KEY='your-openai-api-key'

# 4. 运行模拟
python main.py --cases 10 --personas 9 --verbose

# 5. 查看结果
ls -la results/
```

---

## 🔧 配置选项

### 环境变量
```bash
export OPENAI_API_KEY='your-openai-api-key'
```

### 模型配置
```python
# 在main.py中可修改LLM配置
self.llm = ChatOpenAI(
    base_url='https://api.openai-proxy.org/v1',  # API基础URL
    api_key=self.openai_api_key,                 # API密钥
    model="gpt-3.5-turbo",                       # 模型名称
    temperature=0.7                              # 温度参数
)
```

### 人格生成配置
```python
# 在persona_config.py中可修改人格组合
expertise_levels = [ExpertiseLevel.BEGINNER, ExpertiseLevel.INTERMEDIATE, ExpertiseLevel.EXPERT]
trust_levels = [AITrustLevel.VERY_DISTRUSTING, AITrustLevel.NEUTRAL, AITrustLevel.VERY_TRUSTING]
scale_levels = [ScaleLevel.LOW, ScaleLevel.MEDIUM, ScaleLevel.HIGH]
```

---

## 📈 性能指标与效果评估

### 系统性能
- **平均处理时间**: 7-8秒/次运行
- **内存使用**: 随并发人格数量线性增长
- **ML准确率**: 随机森林模型达到98.36%准确率
- **可重现性**: 相同随机种子产生一致结果

### 心理学真实性验证
- **人格差异性**: 81种人格组合展现显著不同的决策模式
- **量表一致性**: NCS和GSE量表分数与行为表现高度一致
- **信任水平影响**: AI信任度显著影响采纳决策
- **认知负荷体现**: 高认知需求者提供更详细和复杂的分析
- **情感真实性**: 人格表现出真实的情感反应和内在冲突

### 实验结果示例
```
=== 模拟分析 ===
成功运行总数: 81
平均处理时间: 7.84s

决策分布:
  REJECT: 45 (55.6%)
  ACCEPT: 36 (44.4%)

专业水平模式:
  beginner_REJECT: 18
  intermediate_REJECT: 15
  expert_REJECT: 12
  beginner_ACCEPT: 9
  intermediate_ACCEPT: 12
  expert_ACCEPT: 15

信任水平模式:
  trust_-2_REJECT: 25
  trust_0_REJECT: 12
  trust_2_REJECT: 8
  trust_-2_ACCEPT: 2
  trust_0_ACCEPT: 15
  trust_2_ACCEPT: 19

心理量表模式:
  ncs_Low_REJECT: 20
  ncs_Medium_REJECT: 15
  ncs_High_REJECT: 10
  gse_Low_ACCEPT: 8
  gse_Medium_ACCEPT: 14
  gse_High_ACCEPT: 14
```

---

## 🔮 未来增强方向

### 技术优化
1. **并行处理**: 实现多进程/多线程并行执行
2. **缓存机制**: 缓存LLM响应以提高性能
3. **批量API**: 优化API调用减少延迟
4. **内存优化**: 大规模实验的内存管理
5. **模型优化**: 探索更先进的LLM模型

### 功能扩展
1. **更多心理量表**: 集成大五人格、风险偏好、决策风格等量表
2. **动态学习**: 人格基于经验更新决策模式
3. **情境因素**: 添加市场条件、监管环境、时间压力等上下文
4. **多模态输入**: 支持文档、图像等多种输入类型
5. **可视化分析**: 决策树和模式分析工具

### 研究应用
1. **A/B测试**: 不同AI界面设计的用户接受度研究
2. **政策分析**: 监管政策对人类决策行为的影响
3. **培训系统**: 基于心理特征的个性化培训方案
4. **风险评估**: 人机协作中的系统性偏差识别
5. **行为预测**: 预测不同人格在新情境中的行为

---

## 📚 技术依赖

### 核心依赖
```python
langchain==0.1.0          # LangChain框架
langchain-openai==0.0.5   # OpenAI集成
openai==1.6.1             # OpenAI API客户端
pandas==2.1.4             # 数据处理
scikit-learn==1.3.2       # 机器学习
tqdm==4.66.1              # 进度条
joblib==1.3.2             # 模型序列化
numpy==1.24.3             # 数值计算
```

### 完整依赖安装
```bash
pip install langchain langchain-openai openai pandas scikit-learn tqdm joblib numpy
```

---

## 📞 技术支持

### 故障排除
1. **API连接问题**: 检查网络连接和API密钥
2. **内存不足**: 减少并发人格数量或案例数量
3. **模型加载失败**: 确认模型文件路径和格式正确
4. **结果异常**: 检查数据预处理和标签编码一致性
5. **提示工程问题**: 确保心理特征配置正确

### 调试模式
```python
# 启用详细日志
import logging
logging.basicConfig(level=logging.DEBUG)

# 减少测试规模
python main.py --cases 1 --personas 1 --verbose

# 检查人格配置
python persona_config.py
```

### 性能监控
```python
# 监控处理时间
results_df = pd.DataFrame(results)
print(f"平均处理时间: {results_df['processing_time'].mean():.2f}s")
print(f"最长处理时间: {results_df['processing_time'].max():.2f}s")

# 监控成功率
success_rate = len(results_df[results_df['error'].isna()]) / len(results_df)
print(f"成功率: {success_rate:.2%}")
```

---

## 🎯 系统特色总结

### 心理学理论驱动
1. **双过程理论**: 完整实现快思考vs慢思考机制
2. **心理量表**: NCS-18和GSE-10的科学实现
3. **人格差异化**: 81种组合产生显著不同的行为模式
4. **情感真实性**: 真实的人类情感反应和内在冲突

### 技术创新亮点
1. **增强提示工程**: 心理学驱动的复杂人格身份设定
2. **动态适应机制**: 基于心理特征的实时决策调整
3. **多智能体架构**: 快思考和慢思考的独立实现
4. **综合评估系统**: 多维度决策过程完整捕获

### 实验价值
1. **行为研究**: 为人机交互研究提供强大实验平台
2. **AI伦理**: 理解不同人群对AI的接受和信任模式
3. **决策科学**: 深入洞察人类决策制定的心理机制
4. **应用潜力**: 广泛的商业和学术应用前景

---

本文档涵盖了LLM智能体人类行为模拟系统的完整技术实现和最新优化。系统成功结合了心理学理论与人工智能技术，通过增强的提示工程实现了高度真实的人类心理行为模拟，为人机交互研究提供了强大而先进的实验平台。

**文档版本**: v2.0  
**最后更新**: 2025年7月10日  
**维护者**: Claude Code Assistant  
**主要更新**: 增强的心理学提示工程系统，完整的心理量表实现，动态心理适应机制